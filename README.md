The Descent
Пояснения: в начале каждого игрового хода сообщается высота 8 гор слева направо, высота гор выдается системой Coding Game. 
Цель задачи заключается в определение самой высокой горы. Инициализируем переменную maxHeight = -1, как начальное значение 
для поиска максимальной высоты и maxIndex = 0, как индекс самой высокой горы. Далее по программе идет цикл, в котором 
считываются высоты каждой из 8 гор.  В цикле если текущее значение горы больше самого большого из предыдущих, то значение 
переменной maxIndex обновляется. После цикла выводится maxIndex, то есть индекс с самым максимальным значением.


Power of Thor – Episode 1
	Пояснение: в задаче дано поле с координатами X и Y, размером 40 на 18. За каждый ход Тор может перемещаться на один шаг 
 в одном из направлений (N, NE, E SE, S, SW, W, NW), необходимо чтобы Тор достиг  «the light of power». Задача заключается 
 в применение условного оператора. Переменная move типа string используется для хранения направления стороны света куда 
 движется Тор. С помощью условного оператора задаем направление движения Тора. Далее с помощью метода find читаем переменную 
 move и шагаем в нужное направление. string::npos проверяет move на наличие стороны света в данном условном операторе.

 
Temperatures
	Пояснение: В задаче есть n значений температур, необходимо найти ближайшее к нулю. При этом, если температуры по модулю 
 равны, нужно выбрать положительное число. Сначала создаём целочисленную переменную closestToZero, равную 5527 — это значение 
 заведомо больше максимальной возможной температуры, чтобы любое введённое число оказалось ближе к нулю. Для нахождения 
 температуры будем использовать условный оператор if. Функция abs() возвращает модуль числа.  c В конце программы если 
 кол-во температур 0, то выводить t = 0.
 
Mars Lander - Episode 1
Пояснение: Для успешной посадки шаттла необходимо, чтобы вертикальная скорость не превышала 40 м/с по модулю. Если шаттл 
падает, то его скорость по модулю превышает 40 м/c, это значит мы должны включить максимальную мощность тяги 4. Также можно 
расписать и для 30 м/c  (20 м/c, 10 м/c, 0 м/c). Используем условный оператор и проверяем вертикальную скорость шаттла.

Shadows of the Knight - Episode 1
Пояснение: цель задачи заключается в нахождение нужного окна, заданной системой. Нам даны следующие условия: w – ширина матрицы,
h – высота матрицы,  n – максимальное количество ходов, начальные координаты x0 и y0. Система каждый раз дает нам подсказку, 
где находится окно (U, UR, R, DR, D, DL, L or UL). Идея задачи заключается в применение бинарного поиска. На каждом прыжке мы 
считываем подсказку, в зависимости от подсказки выполняем уменьшение всевозможных окон, где находится бомба, пересчитываем 
координаты следующего прыжка, эти координаты становятся текущими. Процесс повторяется до тех пор, пока мы не попадем в окно 
с бомбой. Этот метод позволяет не перебирать все возможные варианты, а добраться до нужного окна наикратчайшим способом.
Так как высота и ширина мax = 10000, то мы укладываемся в 100 прыжков. log₂(10000) ~14, так как у нас две оси (x и y), то 
максимальное кол-во прыжков 28. 


Network Cabling
Пояснение: необходимо найти минимальную суммарную длину кабеля для подключения всех домов. По условию у нас есть один горизонтальный
кабель и по одному вертикальному подведённому к каждому зданию. Для решение этой задачи используем вектор (т.е. есть вектор),
который будет хранить в себе координаты зданий. Задача сводится к тому, чтобы найти длину горизонтального кабеля и длину всех 
вертикальных кабелей. Через функцию *min_element и *max_element найдем минимальную и максимальную координату x (далее через 
разность длину горизонтального кабеля). По определению медианы конечного списка чисел найдем ординату горизонтального кабеля 
(для сортировки используем функцию  sort), далее через цикл считаем длину каждого вертикального кабеля.


Don't Panic - Episode 1
Пояснение: в задаче необходимо помочь клонам найти выход, лабиринт состоит из этажей, на каждом этаже может быть один лифт. Этаж 
состоит из позиций, они пронумерованы слева направо. Этажи начинаются с 0 этажа (самый нижний этаж). Генерация клонов происходит 
в генераторе, после генерации клон движется вправо.С помощью цикла for считываются позиции лифтов на этажах и записываются в 
вектор elevator_pos (индекс вектора — этаж, значение — позиция лифта), если лифта нет на этаже, то в векторе хранится значение -1 
(-1 это общепринятое правило).Далее идёт цикл while. Считываем данные о ведущем клоне (этаж, позиция на этаже, направление движения). 
Если ведущего клона нет (clone_floor == -1) — выводим WAIT и ждем следующего клона.Затем определяется цель клона target. Если клон 
находится на этаже выхода, то целью является позиция выхода (exit_pos), иначе позиция лифта на этом этаже (elevator_pos[clone_floor]). 
Если цели нет (например, лифта на этаже нет, target == -1) — выводим WAIT и ждём следующего клона. Проверка направление движения клона: 
если клон движется в сторону, противоположную цели (идёт влево, а цель справа, или идёт вправо, а цель слева) — выводим BLOCK, чтобы клон 
развернулся. В противном случае — выводим WAIT, чтобы клон продолжал движение к цели.


Cheap Choices
Пояснение:  задача заключается в нахождение подходящей одежды покупателю. У каждого товара есть CATEGORY,  SIZE, и PRICE (каждый товар в 
единственном экземпляре). Каждый покупатель запрашивает определённое CATEGORY и SIZE, и выбирает самый дешёвый вариант. Для хранения товара 
создается структура Item, которая хранит в себе CATEGORY, SIZE, PRICE и sold (показывает продан товар или нет). Далее считываем товары 
через цикл for, будем пользоваться stringstream для разделения потока данных. Для каждой строки создаем объект item типа Item. У следующего 
цикла for логика такая же, только тут мы считываем строку с товаром (товар, необходимый покупателю). Переменная bestPrice необходима для 
сравнения цены, заранее ставим ее очень большой (можно воспользоваться numeric_limits<int>::max()). Переменная bestIndex необходима в том 
случае если подходящего товара нет. Далее еще один цикл for, который проверяет есть ли в нашем векторе нужный товар, если этих товаров 
несколько, то выбираем самый дешевый. Для этого сравниваем с bestPrice (каждую итерацию перезаписывается если это необходимо) . 
В зависимости от индекса выводим через cout "NONE" (если товара нет) или цену товара (если товар подошел) и помечаем его как проданный.

