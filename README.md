The Descent (Easy).
Пояснения: в начале каждого игрового хода сообщается высота 8 гор слева направо, высота гор выдается системой Coding Game. 
Цель задачи заключается в определение самой высокой горы. Инициализируем переменную maxHeight = -1, как начальное значение 
для поиска максимальной высоты и maxIndex = 0, как индекс самой высокой горы. Далее по программе идет цикл, в котором 
считываются высоты каждой из 8 гор.  В цикле если текущее значение горы больше самого большого из предыдущих, то значение 
переменной maxIndex обновляется. После цикла выводится maxIndex, то есть индекс с самым максимальным значением.


Power of Thor – Episode 1 (Easy).
	Пояснение: в задаче дано поле с координатами X и Y, размером 40 на 18. За каждый ход Тор может перемещаться на один шаг 
 в одном из направлений (N, NE, E SE, S, SW, W, NW), необходимо чтобы Тор достиг  «the light of power». Задача заключается 
 в применение условного оператора. Переменная move типа string используется для хранения направления стороны света куда 
 движется Тор. С помощью условного оператора задаем направление движения Тора. Далее с помощью метода find читаем переменную 
 move и шагаем в нужное направление. string::npos проверяет move на наличие стороны света в данном условном операторе.

 
Temperatures (Easy).
	Пояснение: В задаче есть n значений температур, необходимо найти ближайшее к нулю. При этом, если температуры по модулю 
 равны, нужно выбрать положительное число. Сначала создаём целочисленную переменную closestToZero, равную 5527 — это значение 
 заведомо больше максимальной возможной температуры, чтобы любое введённое число оказалось ближе к нулю. Для нахождения 
 температуры будем использовать условный оператор if. Функция abs() возвращает модуль числа.  c В конце программы если 
 кол-во температур 0, то выводить t = 0.

 Unary (Easy).
Пояснение: необходимо написать программу, которая принимает входное сообщение и выводит результат – закодированное сообщение 
в виде нулей. На вход поступает сообщение, состоящее из ASCII-символов (7-битных). Закодированное сообщение должно состоять 
из блоков нулей, блоки разделяются пробелами. Создадим переменную binary типа string, которая будет хранить двоичное 
представление символов сообщения. С помощью цикла проходимся по каждому символу строки message и преобразуем его в 
7-битный двоичный код, добавляя полученные биты (0 или 1) в строку binary (для добавление используем тернарный оператор). 
Далее создадим переменную answer типа string, которая будет хранить наше закодированное сообщение. С помощью цикла while 
пробежимся по всем элементам из строки binary. Для каждого символа определяем какой бит сейчас рассматривается (0 или 1). 
Затем во вложенном цикле считаем количество подряд идущих битов. Потом формируются блоки, если бит равен 1 – в answer 
записываем “0 ”, если бит равен 0 – в answer записываем “00 ”. Вторая часть блока – количество нулей равное длине серии 
одинаковых битов.  После переходим к следующей серии и ставим пробел между сериями. Выводим answer, который хранит наш закодированный код.

 
Mars Lander - Episode 1 (Easy).
Пояснение: Для успешной посадки шаттла необходимо, чтобы вертикальная скорость не превышала 40 м/с по модулю. Если шаттл 
падает, то его скорость по модулю превышает 40 м/c, это значит мы должны включить максимальную мощность тяги 4. Также можно 
расписать и для 30 м/c  (20 м/c, 10 м/c, 0 м/c). Используем условный оператор и проверяем вертикальную скорость шаттла.

Shadows of the Knight - Episode 1 (Medium).
Пояснение: цель задачи заключается в нахождение нужного окна, заданной системой. Нам даны следующие условия: w – ширина матрицы,
h – высота матрицы,  n – максимальное количество ходов, начальные координаты x0 и y0. Система каждый раз дает нам подсказку, 
где находится окно (U, UR, R, DR, D, DL, L or UL). Идея задачи заключается в применение бинарного поиска. На каждом прыжке мы 
считываем подсказку, в зависимости от подсказки выполняем уменьшение всевозможных окон, где находится бомба, пересчитываем 
координаты следующего прыжка, эти координаты становятся текущими. Процесс повторяется до тех пор, пока мы не попадем в окно 
с бомбой. Этот метод позволяет не перебирать все возможные варианты, а добраться до нужного окна наикратчайшим способом.
Так как высота и ширина мax = 10000, то мы укладываемся в 100 прыжков. log₂(10000) ~14, так как у нас две оси (x и y), то 
максимальное кол-во прыжков 28. 


Network Cabling (Medium).
Пояснение: необходимо найти минимальную суммарную длину кабеля для подключения всех домов. По условию у нас есть один горизонтальный
кабель и по одному вертикальному подведённому к каждому зданию. Для решение этой задачи используем вектор (т.е. есть вектор),
который будет хранить в себе координаты зданий. Задача сводится к тому, чтобы найти длину горизонтального кабеля и длину всех 
вертикальных кабелей. Через функцию *min_element и *max_element найдем минимальную и максимальную координату x (далее через 
разность длину горизонтального кабеля). По определению медианы конечного списка чисел найдем ординату горизонтального кабеля 
(для сортировки используем функцию  sort), далее через цикл считаем длину каждого вертикального кабеля.


Don't Panic - Episode 1 (Medium).
Пояснение: в задаче необходимо помочь клонам найти выход, лабиринт состоит из этажей, на каждом этаже может быть один лифт. Этаж 
состоит из позиций, они пронумерованы слева направо. Этажи начинаются с 0 этажа (самый нижний этаж). Генерация клонов происходит 
в генераторе, после генерации клон движется вправо.С помощью цикла for считываются позиции лифтов на этажах и записываются в 
вектор elevator_pos (индекс вектора — этаж, значение — позиция лифта), если лифта нет на этаже, то в векторе хранится значение -1 
(-1 это общепринятое правило).Далее идёт цикл while. Считываем данные о ведущем клоне (этаж, позиция на этаже, направление движения). 
Если ведущего клона нет (clone_floor == -1) — выводим WAIT и ждем следующего клона.Затем определяется цель клона target. Если клон 
находится на этаже выхода, то целью является позиция выхода (exit_pos), иначе позиция лифта на этом этаже (elevator_pos[clone_floor]). 
Если цели нет (например, лифта на этаже нет, target == -1) — выводим WAIT и ждём следующего клона. Проверка направление движения клона: 
если клон движется в сторону, противоположную цели (идёт влево, а цель справа, или идёт вправо, а цель слева) — выводим BLOCK, чтобы клон 
развернулся. В противном случае — выводим WAIT, чтобы клон продолжал движение к цели.


Cheap Choices (Easy).
Пояснение:  задача заключается в нахождение подходящей одежды покупателю. У каждого товара есть CATEGORY,  SIZE, и PRICE (каждый товар в 
единственном экземпляре). Каждый покупатель запрашивает определённое CATEGORY и SIZE, и выбирает самый дешёвый вариант. Для хранения товара 
создается структура Item, которая хранит в себе CATEGORY, SIZE, PRICE и sold (показывает продан товар или нет). Далее считываем товары 
через цикл for, будем пользоваться stringstream для разделения потока данных. Для каждой строки создаем объект item типа Item. У следующего 
цикла for логика такая же, только тут мы считываем строку с товаром (товар, необходимый покупателю). Переменная bestPrice необходима для 
сравнения цены, заранее ставим ее очень большой (можно воспользоваться numeric_limits<int>::max()). Переменная bestIndex необходима в том 
случае если подходящего товара нет. Далее еще один цикл for, который проверяет есть ли в нашем векторе нужный товар, если этих товаров 
несколько, то выбираем самый дешевый. Для этого сравниваем с bestPrice (каждую итерацию перезаписывается если это необходимо) . 
В зависимости от индекса выводим через cout "NONE" (если товара нет) или цену товара (если товар подошел) и помечаем его как проданный.

There is no Spoon - Episode 1 (Medium).
Пояснение: задача заключается в том, чтобы найти соседей справа и снизу у каждого из узла (узел – «0», пустая позиция – «.»). Хранить сетку 
будем в виде строк, для этого создадим вектор grid(height) типа string и с помощью цикла for запишем данные. Если сосед у узла отсутствует , 
то вместо его координат будем записывать «-1 -1» (для этого сразу инициализировали переменные как -1 и -1). Программа проходит по каждой клетки
сетки сверху вниз и слева направо с помощью вложенных циклов (строка 22,23). Если нашли узел , то фиксируем его координаты и ищем ближайший 
соседа справа, если его нет – то координаты x2 = -1 и y2 = -1  (аналогично с поиском соседа снизу). Для каждого узла выводится одна строка с
координатами в порядке: x1 y1 x2 y2 x3 y3.


Death First Search - Episode 1 (Medium).
Пояснение: задача заключается в том, чтобы не дать агенту добраться до шлюза. Сеть представлена в виде узлов  и связей между ними. Некоторые узлы могут быть шлюзами. Сначала программа считывает входные данные: кол-во узлов n, кол-во связей l, кол-во шлюзов e. Далее создаем вектор links типа vector<pair<int,int>>, этот вектор хранит пары узлов. Каждая пара считывается с помощью цикла for и с помощью push_back добавляем каждую пару в конец вектора. Создаем вектор gateways типа vector<int>, этот вектор хранит индексы шлюзов. После начинается основной цикл. В нем указываем индекс узла, где находится агент. Инициализируем переменную cut типа bool в false (false – разрыв еще не произошел). Первый вложенный цикл  отвечает за связь между агентом и шлюзом, если такая связь есть – разрываем ее. Разрываем с помощью связки remove и erase. Remove сдвигает все пары узлов не равные link в начало и возвращает итератор на новый конец вектора. Erase удаляет остаток вектора (остаток не нужных пар узлов).Если разрыв произошел, то cut = true. Если разрыва не произошло (cut = false), то выполняется второй цикл (!cut = true): разрываем связь между узлом и шлюзом. За каждый цикл программы разрываем одну связь. Потом ход агента. И так поочередно до тех пор, пока агенту будет некуда ходить.


